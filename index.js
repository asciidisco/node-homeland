'use strict';

// ext. dependencies
var EventEmitter = require('events').EventEmitter;
var Q = require('q');

// device & pairing manager
var Devices = require('./lib/devices');
var Pairing = require('./lib/pairing');

// connector interfaces
var Connector = {};
Connector.USB = require('./lib/connector/usb');
Connector.LAN = {};

/**
 * Public facade of the node-homeland package
 *
 * @class Homeland
 */

function Homeland (options) {
  options = options || {};
  // default options
  this.options = {
    interface: 'usb',
    port: 1000,
    ip: true
  };

  // merge user defined with default options
  Object.keys(options).forEach(function (key) {
    if (this.options[key]) {
      this.options[key] = options[key];
    }
  } .bind(this));

  // setup local variables
  this.connector = null;
  this.pairing = null;

  // instanciate local dependencies
  this.ee = new EventEmitter();
  this.devices = new Devices();
}

/**
 * Import event emitter (cheap inheritance)
 */

Homeland.prototype = Object.create(EventEmitter.prototype);

/**
 * Connect with the coordinator (HM-CFG-USB2 or HM-CFG-LAN)
 * Initializes the pairing controller
 *
 * @public
 * @method connect
 * @param {function} cb Optional callback that resolves on success/error
 * @return {Q.promise} Promise that resolves on success/error
 */

Homeland.prototype.connect = function (cb) {
  var deferred = Q.defer();
  var _cb = typeof cb === 'function' ? cb : function () {};

  if (Connector[this.options.interface.toUpperCase()]) {
    this.connector = new (Connector[this.options.interface.toUpperCase()])(this.options);
    this._listen();
    this.connector.connect().then(function () {
      this.pairing = new Pairing(this.connector, this.devices, this.ee);
      deferred.resolve(this);
      _cb(null, this);
    } .bind(this)).catch(deferred.reject);
  } else {
    var _err = new Error('No matching connector available for:' + this.options.interface);
    deferred.reject(_err);
    _cb(_err, this);
    return deferred.promise;
  }

  return deferred.promise;
};

/**
 * Reboots the coordinator (implies a downtime of ~30 seconds).
 *
 * @method reboot
 * @param {function} cb A callback function [optional]
 * @return {promise} A Q.promise object
 */

Homeland.prototype.reboot = function (cb) {
  return this.connector.reboot(cb);
};

/**
 * Sets the owner.
 * Must be a 6 character hex value (default 424242)
 * This is needed to control & pair devices (receiving broadcasts works without).
 *
 * The coordinator usually already comes with an ID, I highly recommend to change
 * this ID to something that is generated by the `user`. All the devices that get
 * paired will get this owner ID & only interact with an coordinator with that specific owner ID.
 *
 * If the owner is already set to the value given, nothing happens, if the owner
 * needs to be changed on the coordinator, it may reboots, which implies a downtime
 * of ~30 seconds.
 *
 * @method setOwner
 * @param {string} owner Hex representation of the owner id [optional]
 * @param {function} cb A callback function [optional]
 * @return {promise} A Q.promise object
 */

Homeland.prototype.startPairing = function (sec, cb) {
  return this.pairing.startPairing(sec, cb);
};

/**
 * Sets the owner.
 * Must be a 6 character hex value (default 424242)
 * This is needed to control & pair devices (receiving broadcasts works without).
 *
 * The coordinator usually already comes with an id, I highly recommend to change
 * the id to somehting specific. All the devices that get paired will get this
 * owner id & only interact with an coordinator with that specific owner id.
 *
 * If the owner is already set to the value given, nothing happens, if the owner
 * needs to be changed on the coordinator it gets rebooted, which implies a downtime
 * of ~30 seconds.
 *
 * @method setOwner
 * @param {string} owner Hex representation of the owner id [optional]
 * @param {function} cb A callback function [optional]
 * @return {promise} A Q.promise object
 */

Homeland.prototype.setOwner = function (owner, cb) {
  this.devices.owner = owner = owner || this.devices.owner || 424242;
  return this.connector.setOwner(owner, cb);
};

/**
 * Adds a device which can then be controlled &
 * receive events
 *
 * This is not *pairing* or *device inclusion*, this is for telling
 * the system which already paired devices should be exposed via the interface
 * A device must be paired first before it can be added to the runtime using this method
 *
 * At minimum the method expects an object literal with an `id` (which is the unique hmId of the device)
 * and the `model` of the device (smth. like `HM-CC-TC`)
 * Additionally, you can supply any information you want (like a `name` or the devices `serialNo`),
 * the information will be persistet in the session and remains untuoched but accessible
 *
 * If the promise will be resolved (or the callback will be called without an error), you receive
 * an instance of the concrete device
 *
 * @method addDevice
 * @param {object} deviceMeta Object literal that describes device meta data
 * @param {function} cb A callback function [optional]
 * @return {promise} A Q.promise object
 */

Homeland.prototype.addDevice = function (deviceMeta, cb) {
  var deferred = Q.defer();
  var _err = null;
  var _cb = typeof cb === 'function' ? cb : function () {};

  // check if we have device meta data
  if ((deviceMeta !== Object(deviceMeta)) || (Object.prototype.toString.call(deviceMeta) === '[object Array]')) {
    _err = new Error('[addDevice]: No device meta data given - must be an object literal with at least 2 properties: {id: "12345", model: "HM-CC-TC"}');
    _cb(_err, null);
    deferred.reject(_err);
    return deferred.promise;
  }

  // check if we have valid device meta data
  if (!deviceMeta.id || !deviceMeta.model) {
    _err = new Error('[addDevice]: No device meta data given - must be an object literal with at least 2 properties: {id: "12345", model: "HM-CC-TC"}');
    _cb(_err, null);
    deferred.reject(_err);
    return deferred.promise;
  }

  // generate a device instance
  var _device = this.devices.addDevice({
    hmId: (deviceMeta.id || deviceMeta.hmId),
    model: deviceMeta.model,
    owner: (deviceMeta.owner || this.connector.owner)
  }, deviceMeta);

  // resolve deferred & cb
  deferred.resolve(_device);
  _cb(_err, _device);

  return deferred.promise;
};

/**
 *
 * @private
 * @method _listen
 * @return {Homeland} Chainable self reference
 */

Homeland.prototype._listen = function () {
  // coordinator
  this.connector.on('data', this._processIncoming.bind(this));
  this.connector.on('ready', this.emit.bind(this, 'ready'));

  // devices
  this.devices.on('add', this.emit.bind(this, 'device.add'));
  this.devices.on('remove', this.emit.bind(this, 'device.remove'));
  this.devices.on('internal.sendCommand', this._commandListener.bind(this));

  // pairing
  this.ee.on('device.paired', this.emit.bind(this, 'device.paired'));

  return this;
};

/**
 *
 * @private
 * @method _processIncoming
 * @param {string} data Incoming data from the coordinator
 * @return {Homeland} Chainable self reference
 */

Homeland.prototype._processIncoming = function (data) {
  // emit the broadcast event (spit out all incoming data unprocessed)
  this.emit('broadcast', data);

  // check if the incoming data is associated to an already
  // paired & added device
  if (this.devices.isConnectedDevice(data)) {
    // get the
    this.devices
      .getDeviceFromDataStream(data)
      .parse(data, this.emit.bind(this));
  } else {
    // check if the request is an intention of a device to be paired
    // and if the pairing mode of the coordinator is active
    if (this.pairing.isValidPairingRequest(data) && this.pairing.isPairingModeActive()) {
      this.pairing.startPairingFlow(data);
    } else {
      if (this.pairing.isPairingModeActive() && this.pairing.isCurrentDeviceRequest(data)) {
        setImmediate(this.pairing.processPairingData.bind(this.pairing, data));
      } else {
        // TODO: Emit an error here about an unknown incoming
        // data packet, that does not belong to a knwon device.event or
        // is an invalid pairing request
        console.log('Unknown:', data);
      }
    }
  }

  return this;
};

/**
 *
 */

Homeland.prototype._commandListener = function (buf, text) {
  this.connector.send(buf, text);
};

module.exports = Homeland;